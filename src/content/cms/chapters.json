{
  "01": {
    "name": 1,
    "title": "getting started",
    "subtitle": "A Quick Dip",
    "image": "images/11254.jpg",
    "preview": "## Kotlin is making waves\nFrom it’s first official release, Kotlin …",
    "content": "\n## Kotlin is making waves\nFrom it’s first official release, Kotlin has impressed programmers with its **friendly syntax, conciseness, flexibility and power**. In this book, we’ll teach you how to **build your own Kotlin applications**, and we’ll start by getting you to build a basic application and run it. Along the way, you’ll meet some of Kotlin’s basic syntax, such as *statements, loops and conditional branching*. Your journey has just begun...\n\n## Headings\n\n* Welcome to Kotlinville\n* You can use Kotlin nearly everywhere\n* What we’ll do in this chapter\n* Sharpen your pencil (Exercise)\n* Sharpen your pencil (Solution)\n* Install IntelliJ IDEA (Community Edition)\n* Let's build a basic application\n* You've just created your first Kotlin project\n* Add a new Kotlin file to the project\n* Anatomy of the main function\n* Add the main function to App.kt\n* Test drive\n* What can you say in the main function?\n* Loop and loop and loop...\n* A loopy example\n* Conditional branching\n* Using *if* to return a value\n* Update the main function\n* Code magnets (Exercise)\n* Using the Kotlin interactive shell\n* You can add multi-line code snippets to the REPL\n* Be the Compiler (Exercise)\n* Be the Compiler (Solution)\n* Mixed Messages (Exercise)\n* Mixed Messages (Solution)\n* Code magnets (Solution)\n* Your Kotlin Toolbox\n\n",
    "basename": "01"
  }
,
  "02": {
    "name": 2,
    "title": "basic types and variables",
    "subtitle": "Being a Variable",
    "image": "images/11120.jpg",
    "preview": "## There’s one thing all code depends on—variables \n\rSo in this …",
    "content": "\n## There’s one thing all code depends on—variables \n\rSo in this chapter, we’re going to look under the hood, and show you how **Kotlin variables really work**. You’ll discover Kotlin’s **basic types**, such as *Ints*, *Floats* and *Booleans*, and learn how the Kotlin compiler can **cleverly infer a variable’s type from the value it’s given**. You’ll find out how to use **String templates** to construct complex Strings with very little code, and you’ll learn how to create **arrays** to hold multiple values. Finally, you’ll discover *why objects are so important to life in Kotlinville*.\n\n## Headings\n\n* Your code needs variables\n* What happens when you declare a variable\n* The variable holds a reference to the object\n* Kotlin's basic types\n* How to explicitly declare a variable's type\n* Use the right value for the variable's type\n* Assigning a value to another variable\n* We need to convert the value\n* What happens when you convert a value\n* Watch out for the overspill\n* Sharpen your pencil (Exercise)\n* Sharpen your pencil (Solution)\n* Store multiple values in an array\n* Create the Phrase-O-Matic application\n* Add the code to App.kt\n* String Templates Up Close\n* The compiler infers the array's type from its values\n* var means the variable points to a different array\n* val means the variable points to the same array forever...\n* Be the compiler (Exercise)\n* Code Magnets (Exercise)\n* Mixed References (Exercise)\n* Be the compiler (Solution)\n* Code Magnets (Solution)\n* Mixed References (Solution)\n* Your Kotlin Toolbox\n",
    "basename": "02"
  }
,
  "03": {
    "name": 3,
    "title": "functions",
    "subtitle": "Getting Out of Main",
    "image": "images/11114.jpg",
    "preview": "## It’s time to take it up a notch, and learn about functions.\n\rSo …",
    "content": "\n## It’s time to take it up a notch, and learn about functions.\n\rSo far, all the code you’ve written has been inside your application’s main function. But if you want to write code that’s better organized and easier to maintain, you need to know how to split your code into separate functions. In this chapter, you’ll learn how to write functions and interact with your application by building a game. You’ll discover how to write compact single expression functions. Along the way you’ll find out how to iterate through ranges and collections using the powerful for loop.",
    "basename": "03"
  }
,
  "04": {
    "name": 4,
    "title": "classes and objects",
    "subtitle": "A Bit of Class",
    "image": "images/11240.jpg",
    "preview": "## It’s time we looked beyond Kotlin’s basic types \n\rSooner or …",
    "content": "\n## It’s time we looked beyond Kotlin’s basic types \n\rSooner or later, you’re going to want to use something more than Kotlin’s basic types. And that’s where classes come in. Classes are templates that allow you to create your own types of objects, and define their properties and functions. Here, you’ll learn how to design and define classes, and how to use them to create new types of objects. You’ll meet constructors, initializer blocks, getters and setters, and you’ll discover how they can be used to protect your properties. Finally, you’ll learn how data hiding is built into all Kotlin code, saving you time, effort and a multitude of keystrokes.\n",
    "basename": "04"
  }
,
  "05": {
    "name": 5,
    "title": "superclasses and subclasses",
    "subtitle": "Using your Inheritance",
    "image": "images/11165.jpg",
    "preview": "## Ever found yourself thinking that an object’s type would be …",
    "content": "\n## Ever found yourself thinking that an object’s type would be perfect if you could just change a few things?\n\rWell, that’s one of the advantages of inheritance. Here, you’ll learn how to create subclasses, and inherit the properties and functions of a superclass. You’ll discover how to override functions and properties to make your classes behave the way you want, and you’ll find out when this is (and isn’t) appropriate. Finally, you’ll see how inheritance helps you avoid duplicate code, and how to improve your flexibility with polymorphism.\n",
    "basename": "05"
  }
,
  "06": {
    "name": 6,
    "title": "abstract classes and interfaces",
    "subtitle": "Serious Polymorphism",
    "image": "images/11131.jpg",
    "preview": "## A superclass inheritance hierarchy is just the beginning \n\rIf you …",
    "content": "\n## A superclass inheritance hierarchy is just the beginning \n\rIf you want to fully exploit polymorphism, you need to design using abstract classes and interfaces. In this chapter, you’ll discover how to use abstract classes to control which classes in your hierarchy can and can’t be instantiated. You’ll see how they can force concrete subclasses to provide their own implementations. You’ll find out how to use interfaces to share behavior between independent classes. And along the way, you’ll learn the ins and outs of is, as and when.\n",
    "basename": "06"
  }
,
  "07": {
    "name": 7,
    "title": "data classes",
    "subtitle": "Dealing with Data",
    "image": "images/53212.jpg",
    "preview": "## Nobody wants to spend their life reinventing the wheel\n \rMost …",
    "content": "\n## Nobody wants to spend their life reinventing the wheel\n \rMost applications include classes whose main purpose is to store data, so to make your coding life easier, the Kotlin developers came up with the concept of a data class. Here, you’ll learn how data classes enable you to write code that’s cleaner and more concise than you ever dreamed was possible. You’ll explore the data class utility functions, and discover how to destructure a data object into its component parts. Along the way, you’ll find out how default parameter values can make your code more flexible, and we’ll introduce you to Any, the mother of all superclasses.\n",
    "basename": "07"
  }
,
  "08": {
    "name": 8,
    "title": "nulls and exceptions",
    "subtitle": "Safe and Sound",
    "image": "images/11077.jpg",
    "preview": "## Everybody wants to write code that’s safe \n\rAnd the great news is …",
    "content": "\n## Everybody wants to write code that’s safe \n\rAnd the great news is that Kotlin was designed with code-safety at its heart. We’ll start by showing you how Kotlin’s use of nullable types means that you’ll hardly ever experience a NullPointerException during your entire stay in Kotlinville. You’ll discover how to make safe calls, and how Kotlin’s Elvis operator stops you being all shook up. And when we’re done with nulls, you’ll find out how to throw and catch exceptions like a pro.\n",
    "basename": "08"
  }
,
  "09": {
    "name": 9,
    "title": "collections",
    "subtitle": "Get Organized",
    "image": "images/11004.jpg",
    "preview": "## Ever wanted something more flexible than an array \n\rKotlin comes …",
    "content": "\n## Ever wanted something more flexible than an array \n\rKotlin comes with a bunch of useful collections that give you more flexibility and greater control over how you store and manage groups of objects. Want to keep a resizeable list that you can keep adding to? Want to sort, shuffle or reverse its contents? Want to find something by name? Or do you want something that will automatically weed out duplicates without you lifting a finger? If you want any of these things, or more, keep reading. It’s all here...",
    "basename": "09"
  }
,
  "10": {
    "name": 10,
    "title": "generics",
    "subtitle": "Know your Ins from your Outs",
    "image": "images/11148.jpg",
    "preview": "## Everybody likes code that’s consistent \n\rAnd one way of writing …",
    "content": "\n## Everybody likes code that’s consistent \n\rAnd one way of writing consistent code that’s less prone to problems is to use generics. In this chapter, we’ll look at how Kotlin’s collection classes use generics to stop you from putting a Cabbage into a List<Seagull>. You’ll discover when and how to write your own generic classes, interfaces and functions, and how to restrict a generic type to a specific supertype. Finally, you’ll find out how to use covariance and contravariance, putting YOU in control of your generic type’s behavior.\n",
    "basename": "10"
  }
,
  "11": {
    "name": 11,
    "title": "lambdas & higher-order functions",
    "subtitle": "Treating Code like Data",
    "image": "images/11333.jpg",
    "preview": "## Want to write code that’s even more powerful and flexible \n\rIf …",
    "content": "\n## Want to write code that’s even more powerful and flexible \n\rIf so, then you need lambdas. A lambda—or lambda expression—is a block of code that you can pass round just like an object. Here, you’ll discover how to define a lambda, assign it to a variable, and then execute its code. You’ll learn about function types, and how these can help you write higher-order functions that use lambdas for their parameter or return values. And along the way, you’ll find out how a little syntactic sugar can make your coding life sweeter.\n",
    "basename": "11"
  }
,
  "12": {
    "name": 12,
    "title": "built-in higher-order functions",
    "subtitle": "Power Up your Code",
    "image": "images/11142.jpg",
    "preview": "## Kotlin has an entire host of built-in higher-order functions \n …",
    "content": "\n## Kotlin has an entire host of built-in higher-order functions \n\rAnd in this chapter, we’ll introduce you to some of the most useful ones. You’ll meet the flexible filter family, and discover how they can help you trim your collection down to size. You’ll learn how to transform a collection using map, loop through its items with forEach, and how to group the items in your collection using groupBy. You’ll even use fold to perform complex calculations using just one line of code. By the end of the chapter, you’ll be able to write code more powerful than you ever thought possible.",
    "basename": "12"
  }
,
  "13": {
    "name": "App I",
    "title": "coroutines",
    "subtitle": "Running Code in Parallel",
    "image": "images/11278.jpg",
    "preview": "**Some tasks are best performed in the background.**\n\rIf you want to …",
    "content": "\n**Some tasks are best performed in the background.**\n\rIf you want to read data from a slow external server, you probably don’t want the rest of your code to hang around, waiting for the job to complete. In situations such as these, coroutines are your new BFF. Coroutines let you write code that’s run asynchronously. This means less time hanging around, a better user experience, and it can also make your application more scalable. Keep reading, and you’ll learn the secret of how to talk to Bob, while simultaneously listening to Suzy.\n",
    "basename": "13"
  }
,
  "14": {
    "name": "App II",
    "title": "testing",
    "subtitle": "Hold your Code to Account",
    "image": "images/11199.jpg",
    "preview": "## Everybody knows that good code needs to work.\n\rBut each code …",
    "content": "\n## Everybody knows that good code needs to work.\n\rBut each code change that you make runs the risk of introducing fresh bugs that stop your code from working as it should. That’s why thorough testing is so important: it means you get to know about any problems in your code before it’s deployed to the live environment. In this appendix, we’ll discuss JUnit and KotlinTest, two libraries which you can use to unit test your code so that you always have a safety net.",
    "basename": "14"
  }
,
  "15": {
    "name": "App III",
    "title": "leftovers",
    "subtitle": "The Top Ten Things we didn't cover",
    "image": "images/11287.jpg",
    "preview": "## Even after all that, there’s still a little more.\n\rThere are just …",
    "content": "\n## Even after all that, there’s still a little more.\n\rThere are just a few more things we think you need to know. We wouldn’t feel right about ignoring them, and we really wanted to give you a book you’d be able to lift without training at the local gym. Before you put down the book, read through these tidbits.\n",
    "basename": "15"
  }
}
